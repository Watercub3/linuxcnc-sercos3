/*
CoSeMa V6.1 - Common Sercos Master function library
Copyright (c) 2004 - 2016  Bosch Rexroth AG

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THIS SOFTWARE IS PROVIDED "AS IS"; WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY;
FITNESS FOR A PERTICULAR PURPOSE AND NONINFRINGEMENT. THE AUTHORS OR COPYRIGHT
HOLDERS SHALL NOT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE;
UNLESS STIPULATED BY MANDATORY LAW.

You may contact us at open.source@boschrexroth.de
if you are interested in contributing a modification to the Software.

30 April 2015

============================================================================ */

/*!
 \file   CSMD_SERC_MON_CFG.c
 \author ROL
 \date   01.09.2013
 \brief  This File contains the public API functions and private functions for
         the transmission of the slave configuration.
*/

/*---- Includes: -------------------------------------------------------------*/

#include <stdio.h>

#include "CSMD_GLOB.h"
#include "CSMD_HAL_PRIV.h"
#include "CSMD_DIAG.h"
#include "CSMD_TOPOLOGY.h"

#define SOURCE_CSMD
#include "CSMD_SERC_MON_CFG.h"


#ifdef CSMD_SERCOS_MON_CONFIG

/*---- Definition public Functions: ------------------------------------------*/

/*! \cond PUBLIC */

/**************************************************************************/ /**
\brief Generates the Network Configuration for the Sercos Monitor tool.

\ingroup func_sercmoncfg
\b Description: \n
   Generates the Network Configuration for the Sercos monitor tool.

<B>Call Environment:</B> \n
   The call-up should be performed from a task.\n

\param [in]   prCSMD_Instance
              Pointer to memory range allocated for the variables of the 
              CoSeMa instance
\param [in]   ulMaxBufferLength
              Maximum size of the pcText array in Byte
\param [in]   pcText
              Pointer to array for the configuration output
\param [out]  pulLength
              Number of characters output into the buffer,
              if no error occurs.
  
\return       \ref CSMD_BUFFER_TOO_SMALL \n
              \ref CSMD_NO_ERROR \n
  
\author       ROL
\date         01.09.2013

***************************************************************************** */
CSMD_FUNC_RET CSMD_Serc_Mon_Config( const CSMD_INSTANCE *prCSMD_Instance,
                                    const CSMD_ULONG     ulMaxBufferLength,
                                    CSMD_CHAR           *pcText,
                                    CSMD_ULONG          *pulLength )
{
  CSMD_CHAR     *pcEnd   = &pcText[ulMaxBufferLength - CSMD_MAX_EXPECTED_LINE_LENGTH];
  CSMD_CHAR     *pcStart = pcText;
  CSMD_ULONG     ulIndentation = 0;
  CSMD_FUNC_RET  e__return;

  *pulLength = 0;
  if (ulMaxBufferLength < CSMD_MIN_BUFFER_LENTGH)  return CSMD_BUFFER_TOO_SMALL;

  pcText = &pcText[ sprintf(pcText,"%s", XML_Header) ];

  pcText = CSMD_Serc_XML_Node_Begin( pcText, pcEnd, &ulIndentation, "SercosMonitorSettings" );

  e__return = CSMD_Serc_Mon_Setting_Header( &pcText, pcEnd, &ulIndentation, CSMD_SERCMON_MAJOR_VER, CSMD_SERCMON_MINOR_VER );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  pcText = CSMD_Serc_XML_Node_Begin( pcText, pcEnd, &ulIndentation, "NetworkConfiguration" );

  pcText = CSMD_Serc_XML_Node_Begin( pcText, pcEnd, &ulIndentation, "ConfigurationVersion" );
  pcText = CSMD_Serc_XML_Element_Dezimal( pcText, pcEnd, &ulIndentation, CSMD_SERCMON_CFG_MAJOR_VER, "MajorRevision" );
  pcText = CSMD_Serc_XML_Element_Dezimal( pcText, pcEnd, &ulIndentation, CSMD_SERCMON_CFG_MINOR_VER, "MinorRevision" );
  pcText = CSMD_Serc_XML_Node_End( pcText, pcEnd, &ulIndentation, "ConfigurationVersion" );

  pcText = CSMD_Serc_XML_Node_Begin( pcText, pcEnd, &ulIndentation, "FileInformation" );
  pcText = CSMD_Serc_XML_Element_Begin( pcText, pcEnd, &ulIndentation, "ConfigurationName" );
  pcText = &pcText[ sprintf( pcText, "%s%d%s%d%s%d", "Configuration generated by CoSeMa ",
                    CSMD_DRV_VERSION, ".", CSMD_DRV_MINOR_VERSION, ".", CSMD_DRV_RELEASE ) ];
  pcText = CSMD_Serc_XML_Element_End( pcText, pcEnd, "ConfigurationName" );
  pcText = CSMD_Serc_XML_Node_End( pcText, pcEnd, &ulIndentation, "FileInformation" );

  pcText = CSMD_Serc_XML_Node_Begin( pcText, pcEnd, &ulIndentation, "PluginConfigurations" );
  if (pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }

  e__return = CSMD_Serc_Mon_PluginConfig( prCSMD_Instance, &pcText, pcEnd, &ulIndentation, "FramePlugin", 1, 0, "No Ethernet Tap" );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  e__return = CSMD_Serc_Mon_PluginConfig( prCSMD_Instance, &pcText, pcEnd, &ulIndentation, "SercosPlugin", 1, 3, NULL );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  e__return = CSMD_Serc_Mon_PluginConfig( prCSMD_Instance, &pcText, pcEnd, &ulIndentation, "SmpPlugin", 1, 0, NULL );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  e__return = CSMD_Serc_Mon_PluginConfig( prCSMD_Instance, &pcText, pcEnd, &ulIndentation, "GenericNodesPlugin", 1, 0, NULL );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  pcText = CSMD_Serc_XML_Node_End( pcText, pcEnd, &ulIndentation, "PluginConfigurations" );

  pcText = CSMD_Serc_XML_Node_End( pcText, pcEnd, &ulIndentation, "NetworkConfiguration" );
  pcText = CSMD_Serc_XML_Node_End( pcText, pcEnd, &ulIndentation, "SercosMonitorSettings" );
  if (pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }

  *pulLength = (CSMD_ULONG)(pcText - pcStart);

  return (CSMD_NO_ERROR);
}

/*! \endcond */ /* PUBLIC */


/*---- Definition private Functions: -----------------------------------------*/

/*! \cond PRIVATE */


/*******************************************/
/* Sub-function for "PluginConfiguration"  */
/*******************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_PluginConfig( const CSMD_INSTANCE  *prCSMD_Instance,
                                          CSMD_CHAR           **pcText,
                                          const CSMD_CHAR      *pcEnd,
                                          CSMD_ULONG           *pulIndentation,
                                          const CSMD_CHAR      *pcName,
                                          const CSMD_LONG       lMajorRevision,
                                          const CSMD_LONG       lMinorRevision,
                                          const CSMD_CHAR      *pcName1 )
{
  CSMD_FUNC_RET e__return;

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "PluginConfiguration" );
  e__return = CSMD_Serc_Mon_Plugin( pcText, pcEnd, pulIndentation, pcName, lMajorRevision, lMinorRevision);
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  if (CSMD_HAL_strncmp("FramePlugin", pcName, 32) == 0)
  {
    e__return = CSMD_Serc_Mon_FramePlugin( pcText, pcEnd, pulIndentation, pcName1);
  }
  else if (CSMD_HAL_strncmp("GenericNodesPlugin", pcName, 32) == 0)
  {
    e__return = CSMD_Serc_Mon_GenericNodes( pcText, pcEnd, pulIndentation, pcName1);
  }
  else if (CSMD_HAL_strncmp("SercosPlugin", pcName, 32) == 0)
  {
    e__return = CSMD_Serc_Mon_SercosPlugin( prCSMD_Instance, pcText, pcEnd, pulIndentation );
  }
  else if (CSMD_HAL_strncmp("SmpPlugin", pcName, 32) == 0)
  {
    e__return = CSMD_Serc_Mon_SmpPlugin( pcText, pcEnd, pulIndentation, pcName1 );
  }
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "PluginConfiguration" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }

  return CSMD_NO_ERROR;
}


/********************************************/
/* Sub-function for "Plugin" version        */
/********************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_Plugin( CSMD_CHAR       **pcText,
                                    const CSMD_CHAR  *pcEnd,
                                    CSMD_ULONG       *pulIndentation,
                                    const CSMD_CHAR  *pcName,
                                    const CSMD_LONG   lMajorRevision,
                                    const CSMD_LONG   lMinorRevision )
{
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Plugin" );

  *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, pcName, "Name" );

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "ConfigurationVersion" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, lMajorRevision, "MajorRevision" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, lMinorRevision, "MinorRevision" );

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "ConfigurationVersion" );
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Plugin" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }

  return CSMD_NO_ERROR;
}


/********************************************/
/* Sub-function for "SettingHeader"         */
/********************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_Setting_Header( CSMD_CHAR       **pcText,
                                            const CSMD_CHAR  *pcEnd,
                                            CSMD_ULONG       *pulIndentation,
                                            const CSMD_LONG   lMajorRevision,
                                            const CSMD_LONG   lMinorRevision )
{
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "SettingsHeader" );
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Revision" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, lMajorRevision, "MajorRevision" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, lMinorRevision, "MinorRevision" );

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Revision" );
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "SettingsHeader" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }

  return CSMD_NO_ERROR;
}


/************************************************/
/* Sub-function for "Configuration EthernetTap" */
/************************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_FramePlugin( CSMD_CHAR       **pcText,
                                         const CSMD_CHAR  *pcEnd,
                                         CSMD_ULONG       *pulIndentation,
                                         const CSMD_CHAR  *pcName1 )
{
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Configuration" );
  if (pcName1 == NULL)
  {
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "EthernetTap");
  }
  else
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, pcName1, "EthernetTap" );
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Configuration" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/*************************************************/
/* Sub-function for "Configuration GenericNodes" */
/*************************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_GenericNodes( CSMD_CHAR       **pcText,
                                          const CSMD_CHAR  *pcEnd,
                                          CSMD_ULONG       *pulIndentation,
                                          const CSMD_CHAR  *pcName1 )
{
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Configuration" );
  if (pcName1 == NULL)
  {
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "GenericNodes");
  }
  else
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, pcName1, "GenericNodes" );
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Configuration" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/**************************************************/
/* Sub-function for  "Configuration SercosPlugin" */
/**************************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_SercosPlugin( const CSMD_INSTANCE  *prCSMD_Instance,
                                          CSMD_CHAR           **pcText,
                                          const CSMD_CHAR      *pcEnd,
                                          CSMD_ULONG           *pulIndentation )
{
  CSMD_FUNC_RET e__return;

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Configuration" );

  e__return = CSMD_Serc_Mon_MasterConfig(  prCSMD_Instance,
                                           pcText,
                                           pcEnd,
                                           pulIndentation );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "NetworkConfigurationElement" );
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "NetworkTopology" );

  e__return = CSMD_Serc_Mon_NetworkTopology(  pcText,
                                              pcEnd,
                                              pulIndentation,
                                              "NetworkTopologyType",
                                              prCSMD_Instance->usCSMD_Topology );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "NetworkComponents" );

  e__return = CSMD_Serc_Mon_NetworkComponents( prCSMD_Instance,
                                               pcText,
                                               pcEnd,
                                               pulIndentation );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "NetworkComponents" );
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "NetworkTopology" );
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "NetworkConfigurationElement" );

  
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "SlavesConfigurationElement" );
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Slaves" );
  e__return = CSMD_Serc_Mon_All_Slave_Configs( prCSMD_Instance,
                                               pcText,
                                               pcEnd,
                                               pulIndentation );

  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Slaves" );
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "SlavesConfigurationElement" );

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "ConnectionsConfigurationElement" );
  *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "true", "UpdateOffsetsAndLengthsOfConnectionElements" );
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Connections" );

  e__return = CSMD_Serc_Mon_All_ConfigurationSlave( prCSMD_Instance,
                                                    pcText,
                                                    pcEnd,
                                                    pulIndentation );

  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Connections" );
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "ConnectionsConfigurationElement" );


  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Configuration" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/***********************************************/
/* Sub-function for  "Configuration SmpPlugin" */
/***********************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_SmpPlugin( CSMD_CHAR       **pcText,
                                       const CSMD_CHAR  *pcEnd,
                                       CSMD_ULONG       *pulIndentation,
                                       const CSMD_CHAR  *pcName1 )
{
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Configuration" );

  if (pcName1 == NULL)
  {
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ConfiguredSessions" );
  }
  else
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, pcName1, "ConfiguredSessions" );
  }

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Configuration" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/*****************************************/
/* Sub-function for Master Configuration */
/*****************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_MasterConfig( const CSMD_INSTANCE  *prCSMD_Instance,
                                          CSMD_CHAR           **pcText,
                                          const CSMD_CHAR      *pcEnd,
                                          CSMD_ULONG           *pulIndentation )
{
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "MasterConfigurationElement" );
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "TimingParameter" );

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "SvcBusyTimeout" );
  *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "Enabled" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)prCSMD_Instance->rPriv.rHW_Init_Struct.usSVC_BusyTimeout, "Value" );
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "SvcBusyTimeout");

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "TimingParameter");
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "MasterConfigurationElement");

  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/****************************************/
/* Sub-function for Network topology    */
/****************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_NetworkTopology( CSMD_CHAR        **pcText,
                                             const CSMD_CHAR   *pcEnd,
                                             const CSMD_ULONG  *pulIndentation,
                                             CSMD_CHAR         *pcElementName,
                                             CSMD_USHORT        usTopology )
{
  switch (usTopology)
  {
    case CSMD_NO_LINK:
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Undefined", pcElementName );
      break;
    case CSMD_TOPOLOGY_DEFECT_RING:
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "DefectRing", pcElementName );
      break;
    case CSMD_TOPOLOGY_BROKEN_RING:
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "DoubleLine", pcElementName );
      break;
    case CSMD_TOPOLOGY_LINE_P1:
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Line", pcElementName );
      break;
    case CSMD_TOPOLOGY_LINE_P2:
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Line", pcElementName );
      break;
    case CSMD_TOPOLOGY_RING:
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Ring", pcElementName );
      break;
    default:
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Undefined", pcElementName );
      break;
  }
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/********************************************/
/* Sub-function for "NetworkComponentSlave" */
/********************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_NetworkComponents( const CSMD_INSTANCE  *prCSMD_Instance,
                                               CSMD_CHAR           **pcText,
                                               const CSMD_CHAR      *pcEnd,
                                               CSMD_ULONG           *pulIndentation )
{

  CSMD_USHORT  usSlaveIdx;
  CSMD_USHORT  usTopoIdx  = 1;
  CSMD_BOOL    boPort1;
  CSMD_BOOL    boPort2;
  CSMD_CHAR   *pacPort1;
  CSMD_CHAR   *pacPort2;

  CSMD_Serc_Mon_Topology_Port( prCSMD_Instance,
                               &boPort1,
                               &boPort2,
                               &pacPort1,
                               &pacPort2 );

  if (boPort1 == TRUE)
  {
    for (usSlaveIdx = 0; usSlaveIdx < prCSMD_Instance->rPriv.rSlaveAvailable.usAddressNmb; usSlaveIdx++, usTopoIdx++)
    {
      *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "NetworkComponentSlave");

      /* todo Info for PosAfterTopologyIndex */
      *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(usTopoIdx-1), "PosAfterTopologyIndex" );
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, pacPort1, "PrimaryOrSecondaryPort" );
      *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)usTopoIdx, "TopologyIndex" );
      *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                               (CSMD_LONG)prCSMD_Instance->rPriv.rSlaveAvailable.ausAddresses[usSlaveIdx], "SercosAddress" );

      *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "NetworkComponentSlave");
      if (*pcText > pcEnd)
      {
        return CSMD_BUFFER_TOO_SMALL;
      }
    }
  }

  if (boPort2 == TRUE)
  {
    for (usSlaveIdx = 0; usSlaveIdx < prCSMD_Instance->rPriv.rSlaveAvailable2.usAddressNmb; usSlaveIdx++, usTopoIdx++)
    {
      *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "NetworkComponentSlave");

      /* todo Info for PosAfterTopologyIndex */
      *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(usTopoIdx-1), "PosAfterTopologyIndex" );
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, pacPort2, "PrimaryOrSecondaryPort" );
      *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(usTopoIdx), "TopologyIndex" );
      *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                               (CSMD_LONG)prCSMD_Instance->rPriv.rSlaveAvailable2.ausAddresses[usSlaveIdx], "SercosAddress" );

      *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "NetworkComponentSlave");
      if (*pcText > pcEnd)
      {
        return CSMD_BUFFER_TOO_SMALL;
      }
    }
  }
#if(0)  /* Position of the network tap(s) is unknown */
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "NetworkComponentTap" );
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "NetworkComponentTap" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
#endif
  return CSMD_NO_ERROR;
}


/************************************************/
/* Sub-function for Configuration of all slaves */
/************************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_All_Slave_Configs( const CSMD_INSTANCE  *prCSMD_Instance,
                                               CSMD_CHAR           **pcText,
                                               const CSMD_CHAR      *pcEnd,
                                               CSMD_ULONG           *pulIndentation )
{
  CSMD_FUNC_RET e__return = CSMD_NO_ERROR;
  CSMD_USHORT  usI;
  CSMD_ULONG   ulSercosAdd, ulSlaveIdx;
  CSMD_ULONG   ulTopoIdx  = 1;
  CSMD_BOOL    boPort1;
  CSMD_BOOL    boPort2;
  CSMD_CHAR   *pacPort1;
  CSMD_CHAR   *pacPort2;
  CSMD_BOOL    boFoundSync  = FALSE;
  CSMD_BOOL    boIsTimeEval = FALSE;


  CSMD_Serc_Mon_Topology_Port( prCSMD_Instance,
                               &boPort1,
                               &boPort2,
                               &pacPort1,
                               &pacPort2 );

  if (boPort1 == TRUE)
  {
    for (usI = 0; usI < prCSMD_Instance->rPriv.rSlaveAvailable.usAddressNmb; usI++, ulTopoIdx++)
    {
      ulSercosAdd = prCSMD_Instance->rPriv.rSlaveAvailable.ausAddresses[usI];
      ulSlaveIdx  = prCSMD_Instance->rSlaveList.ausProjSlaveIdxList[ulSercosAdd];

      if (FALSE == boFoundSync)
      {
        if (   (prCSMD_Instance->rPriv.aulSCP_Config[ulSlaveIdx] & CSMD_SCP_SYNC)
               /* Last slave at port 1 and line topology */
            || (   (usI == (prCSMD_Instance->rPriv.rSlaveAvailable.usAddressNmb - 1))
                && (boPort2 == FALSE))
           )
        {
          boFoundSync  = TRUE;  /* Slave with SCP_sync found */
          boIsTimeEval = TRUE;  /* This is the slave for evaluating the timing */
        }
      }
      e__return = CSMD_Serc_Mon_SlaveConfig( prCSMD_Instance,
                                             pcText,
                                             pcEnd,
                                             pulIndentation,
                                             pacPort1,
                                             ulTopoIdx,
                                             ulSercosAdd,
                                             ulSlaveIdx,
                                             boIsTimeEval );

      boIsTimeEval = FALSE;

      if (e__return != CSMD_NO_ERROR)
      {
        return e__return;
      }
    }
  }

  if (boPort2 == TRUE)
  {
    for (usI = 0; usI < prCSMD_Instance->rPriv.rSlaveAvailable2.usAddressNmb; usI++, ulTopoIdx++)
    {
      ulSercosAdd = prCSMD_Instance->rPriv.rSlaveAvailable2.ausAddresses[usI];
      ulSlaveIdx  = prCSMD_Instance->rSlaveList.ausProjSlaveIdxList[ulSercosAdd];

      if (FALSE == boFoundSync)
      {
        if (   (prCSMD_Instance->rPriv.aulSCP_Config[ulSlaveIdx] & CSMD_SCP_SYNC)
               /* Last slave at port 2  */
            || (usI == (prCSMD_Instance->rPriv.rSlaveAvailable2.usAddressNmb - 1))
           )
        {
          boFoundSync  = TRUE;  /* Slave with SCP_sync found */
          boIsTimeEval = TRUE;  /* This is the slave for evaluating the timing */
        }
      }
      e__return = CSMD_Serc_Mon_SlaveConfig( prCSMD_Instance,
                                             pcText,
                                             pcEnd,
                                             pulIndentation,
                                             pacPort2,
                                             ulTopoIdx,
                                             ulSercosAdd,
                                             ulSlaveIdx,
                                             boIsTimeEval );

      boIsTimeEval = FALSE;

      if (e__return != CSMD_NO_ERROR)
      {
        return e__return;
      }
    }
  }
  return e__return;
}


/****************************************/
/* Sub-function for Slave Configuration */
/****************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_All_ConfigurationSlave( const CSMD_INSTANCE  *prCSMD_Instance,
                                                    CSMD_CHAR           **pcText,
                                                    const CSMD_CHAR      *pcEnd,
                                                    CSMD_ULONG           *pulIndentation )
{
  CSMD_FUNC_RET e__return = CSMD_NO_ERROR;
  CSMD_USHORT  usI;
  CSMD_ULONG   ulSercosAdd, ulSlaveIdx, ulConIdx;
  CSMD_ULONG   ulTopoIdx  = 1;
  CSMD_BOOL    boPort1;
  CSMD_BOOL    boPort2;
  CSMD_CHAR   *pacPort1;
  CSMD_CHAR   *pacPort2;

  CSMD_Serc_Mon_Topology_Port( prCSMD_Instance,
                               &boPort1,
                               &boPort2,
                               &pacPort1,
                               &pacPort2 );

  if (boPort1 == TRUE)
  {
    for (usI = 0; usI < prCSMD_Instance->rPriv.rSlaveAvailable.usAddressNmb; usI++, ulTopoIdx++)
    {
      ulSercosAdd = prCSMD_Instance->rPriv.rSlaveAvailable.ausAddresses[usI];
      ulSlaveIdx  = prCSMD_Instance->rSlaveList.ausProjSlaveIdxList[ulSercosAdd];

      for (ulConIdx = 0; ulConIdx < prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].usMaxNbrOfConnections; ulConIdx++)
      {
        if (ulConIdx < prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].usNbrOfConnections)
        {
          e__return = CSMD_Serc_Mon_ConfigurationSlave( prCSMD_Instance,
                                                        pcText,
                                                        pcEnd,
                                                        pulIndentation,
                                                        ulConIdx,
                                                        prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].arConnIdxList[ulConIdx],
                                                        ulTopoIdx,
                                                        ulSercosAdd );
        }
        else
        {
          e__return = CSMD_Serc_Mon_ConfigSlave_Unused( pcText,
                                                        pcEnd,
                                                        pulIndentation,
                                                        ulConIdx,
                                                        ulTopoIdx,
                                                        ulSercosAdd );
        }
        if (e__return != CSMD_NO_ERROR)
        {
          return e__return;
        }
      }
    }
  }

  if (boPort2 == TRUE)
  {
    for (usI = 0; usI < prCSMD_Instance->rPriv.rSlaveAvailable2.usAddressNmb; usI++, ulTopoIdx++)
    {
      ulSercosAdd = prCSMD_Instance->rPriv.rSlaveAvailable2.ausAddresses[usI];
      ulSlaveIdx  = prCSMD_Instance->rSlaveList.ausProjSlaveIdxList[ulSercosAdd];

      for (ulConIdx = 0; ulConIdx < prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].usMaxNbrOfConnections; ulConIdx++)
      {
        if (ulConIdx < prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].usNbrOfConnections)
        {
          e__return = CSMD_Serc_Mon_ConfigurationSlave( prCSMD_Instance,
                                                        pcText,
                                                        pcEnd,
                                                        pulIndentation,
                                                        ulConIdx,
                                                        prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].arConnIdxList[ulConIdx],
                                                        ulTopoIdx,
                                                        ulSercosAdd );
        }
        else
        {
          e__return = CSMD_Serc_Mon_ConfigSlave_Unused( pcText,
                                                        pcEnd,
                                                        pulIndentation,
                                                        ulConIdx,
                                                        ulTopoIdx,
                                                        ulSercosAdd );
        }
        if (e__return != CSMD_NO_ERROR)
        {
          return e__return;
        }
      }
    }
  }
  return e__return;
}


/**************************************************/
/* Sub-function for topology and port information */
/**************************************************/

CSMD_VOID CSMD_Serc_Mon_Topology_Port( const CSMD_INSTANCE  *prCSMD_Instance,
                                       CSMD_BOOL            *pboPort1,
                                       CSMD_BOOL            *pboPort2,
                                       CSMD_CHAR           **pacPort1,
                                       CSMD_CHAR           **pacPort2 )
{
  *pboPort1 = FALSE;
  *pboPort2 = FALSE;
  *pacPort1 = PrimaryPort;
  *pacPort2 = SecondaryPort;

  switch (prCSMD_Instance->usCSMD_Topology)
  {
    case CSMD_NO_LINK:
      break;
    case CSMD_TOPOLOGY_DEFECT_RING:
      if (prCSMD_Instance->rPriv.rRedundancy.usRingDefect == CSMD_RING_DEF_PRIMARY)
      {
        *pboPort2 = TRUE;
        *pacPort2 = BothPorts;
      }
      else
      {
        *pboPort1 = TRUE;
        *pacPort1 = BothPorts;
      }
      break;
    case CSMD_TOPOLOGY_BROKEN_RING:
      *pboPort1 = TRUE;
      *pboPort2 = TRUE;
      break;
    case CSMD_TOPOLOGY_LINE_P1:
      *pboPort1 = TRUE;
      break;
    case CSMD_TOPOLOGY_LINE_P2:
      *pboPort2 = TRUE;
      break;
    case CSMD_TOPOLOGY_RING:
      *pboPort1 = TRUE;
      *pacPort1 = BothPorts;
      break;
    default:
      break;
  }
}


/****************************/
/* Sub-function for "Slave" */
/****************************/

CSMD_FUNC_RET CSMD_Serc_Mon_SlaveConfig( const CSMD_INSTANCE  *prCSMD_Instance,
                                         CSMD_CHAR           **pcText,
                                         const CSMD_CHAR      *pcEnd,
                                         CSMD_ULONG           *pulIndentation,
                                         const CSMD_CHAR      *pcMasterP,
                                         const CSMD_ULONG      ulTopologyI,
                                         const CSMD_ULONG      ulSercosA,
                                         CSMD_ULONG            ulSlaveIdx,
                                         CSMD_BOOL             boSlaveForTimeEval )
{
  CSMD_FUNC_RET e__return;
  CSMD_ULONG    ul__TopologyII;

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Slave" );

  *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, pcMasterP, "ConnectedToMasterPort" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(ulTopologyI), "TopologyIndex" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(ulSercosA), "SercosAddress" );
  *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ComponentName" );
  *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "VendorName" );
  *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "0", "VendorCode" );
  *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "DeviceName" );
  *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "VendorDeviceId" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "DeviceControlStatusTelegramOffsetCp1Cp2");
  ul__TopologyII = (ulTopologyI/CSMD_MAX_SLAVES_PER_TEL_CP1_2)<<12;
  ul__TopologyII |= CSMD_MAX_SLAVES_PER_TEL_CP1_2*6 + 4*(ulTopologyI-(ulTopologyI/CSMD_MAX_SLAVES_PER_TEL_CP1_2)*CSMD_MAX_SLAVES_PER_TEL_CP1_2);
  e__return = CSMD_Serc_Mon_DeviceSvc( pcText,
                                       pcEnd,
                                       pulIndentation,
                                       "MDT",
                                       ul__TopologyII );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "DeviceControlStatusTelegramOffsetCp1Cp2");


  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "DeviceControlTelegramOffsetCp3Cp4");
  e__return = CSMD_Serc_Mon_DeviceSvc( pcText,
                                       pcEnd,
                                       pulIndentation,
                                       "MDT",
                                       (CSMD_ULONG)prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].rTelegramConfig.usC_DEV_OffsetMDT_S01009 );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "DeviceControlTelegramOffsetCp3Cp4");


  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "DeviceStatusTelegramOffsetCp3Cp4");
  e__return = CSMD_Serc_Mon_DeviceSvc( pcText,
                                       pcEnd,
                                       pulIndentation,
                                       "AT",
                                       (CSMD_ULONG)prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].rTelegramConfig.usS_DEV_OffsetAT_S01011 );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "DeviceStatusTelegramOffsetCp3Cp4");

  
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "SvcTelegramOffsetCp1Cp2");
  ul__TopologyII = (ulTopologyI/128)<<12;
  ul__TopologyII |= 6*(ulTopologyI-(ulTopologyI/128)*128);
  e__return = CSMD_Serc_Mon_DeviceSvc( pcText,
                                       pcEnd,
                                       pulIndentation,
                                       "MDT",
                                       ul__TopologyII );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "SvcTelegramOffsetCp1Cp2");


  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "SvcTelegramOffsetCp3Cp4Mdt");
  e__return = CSMD_Serc_Mon_DeviceSvc( pcText,
                                       pcEnd,
                                       pulIndentation,
                                       "MDT",
                                       (CSMD_ULONG)prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].rTelegramConfig.usSvcOffsetMDT_S01013 );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "SvcTelegramOffsetCp3Cp4Mdt");


  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "SvcTelegramOffsetCp3Cp4At");
  e__return = CSMD_Serc_Mon_DeviceSvc( pcText,
                                       pcEnd,
                                       pulIndentation,
                                       "AT",
                                       (CSMD_ULONG)prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].rTelegramConfig.usSvcOffsetAT_S01014 );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "SvcTelegramOffsetCp3Cp4At");


  e__return = CSMD_Serc_Mon_Resources( pcText,
                                       pcEnd,
                                       pulIndentation,
                                       ulSlaveIdx,
                                       &prCSMD_Instance->rConfiguration );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  e__return = CSMD_Serc_Mon_Timing( prCSMD_Instance,
                                    pcText,
                                    pcEnd,
                                    pulIndentation,
                                    ulSlaveIdx,
                                    boSlaveForTimeEval );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Slave" );
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;

} /* end: CSMD_Serc_Mon_SlaveConfig() */


/*******************************************************/
/* Sub-function for "MdtOrAt" (telegram offset and nbr */
/*******************************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_DeviceSvc( CSMD_CHAR        **pcText,
                                       const CSMD_CHAR   *pcEnd,
                                       const CSMD_ULONG  *pulIndentation,
                                       const CSMD_CHAR   *pcMdtOrAt,
                                       const CSMD_ULONG   ulTopologyI )
{
  *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, pcMdtOrAt, "MdtOrAt" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)((ulTopologyI & 0xf000)>>12), "TelegramNumber" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(ulTopologyI & 0x0fff), "ByteOffset" );

  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/********************************/
/* Sub-function for "Resources" */
/********************************/

CSMD_FUNC_RET CSMD_Serc_Mon_Resources( CSMD_CHAR                **pcText,
                                       const CSMD_CHAR           *pcEnd,
                                       CSMD_ULONG                *pulIndentation,
                                       CSMD_ULONG                 ulSlaveIdx,
                                       const CSMD_CONFIG_STRUCT  *prConfiguration )
{

  CSMD_USHORT  usConfIdx;
  CSMD_USHORT  usI, usIDN_Cnt;
  CSMD_ULONG  *pulIDN_List;
  CSMD_ULONG   ulResource = CSMD_RESOURCE_UNKNOWN;

  /* "S-0-1302.x.01 FSP Type & Version" is not accessible. Try to evaluate FSP-Type */
  for (usI = 0; usI < prConfiguration->parSlaveConfig[ulSlaveIdx].usNbrOfConnections; usI++)
  {
    usConfIdx   = prConfiguration->parSlaveConfig[ulSlaveIdx].arConnIdxList[usI].usConfigIdx;
    pulIDN_List = (CSMD_ULONG *)&prConfiguration->parConfiguration[usConfIdx].ulS_0_1050_SE6[1];

    for (usIDN_Cnt=0; usIDN_Cnt < CSMD_MAX_IDN_PER_CONNECTION; usIDN_Cnt++)
    {
      if ((prConfiguration->parConfiguration[usConfIdx].usS_0_1050_SE1 & CSMD_S_0_1050_SE1_TYPE) == CSMD_S_0_1050_SE1_IDN_LIST)
      {
        if (   (pulIDN_List[usIDN_Cnt] == CSMD_IDN_S_0_0134)
            || (pulIDN_List[usIDN_Cnt] == CSMD_IDN_S_0_0135) )
        {
          ulResource = CSMD_RESOURCE_FSP_DRIVE;
          break;
        }
      }
      else if ((prConfiguration->parConfiguration[usConfIdx].usS_0_1050_SE1 & CSMD_S_0_1050_SE1_TYPE) == CSMD_S_0_1050_SE1_FSP_DRIVE)
      {
        ulResource = CSMD_RESOURCE_FSP_DRIVE;
        break;
      }
      else if (   ((pulIDN_List[usIDN_Cnt] & ~CSMD_IDN_SI_MASK) == CSMD_IDN_S_1500_0_1 )
               || ((pulIDN_List[usIDN_Cnt] & ~CSMD_IDN_SI_MASK) == CSMD_IDN_S_1500_0_2) )
      {
        ulResource = CSMD_RESOURCE_FSP_IO;
        break;
      }
      else if (   ((pulIDN_List[usIDN_Cnt] & ~CSMD_IDN_SI_MASK) == CSMD_IDN_S_0600_0_1 )
               || ((pulIDN_List[usIDN_Cnt] & ~CSMD_IDN_SI_MASK) == CSMD_IDN_S_0605_0_1) )
      {
        ulResource = CSMD_RESOURCE_FSP_ENCODER;
        break;
      }
      else if (   (pulIDN_List[usIDN_Cnt]  == CSMD_IDN_S_1720_0_1)
               || (pulIDN_List[usIDN_Cnt]  == CSMD_IDN_S_1720_0_2) )
      {
        ulResource = CSMD_RESOURCE_FSP_POWER_SUPPLY;
        break;
      }
    }
    if (ulResource != CSMD_RESOURCE_UNKNOWN)
    {
      break;
    }
  }

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Resources");
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Resource" );

  if (ulResource == CSMD_RESOURCE_FSP_DRIVE)
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "IsMfSpecific" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, CSMD_FSP_TYPE_DRIVE, "ResourceId" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, CSMD_FSP_VERS_DRIVE, "ResourceVersion" );
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "FSP Drive", "ResourceName" );
  }
  else if (ulResource == CSMD_RESOURCE_FSP_IO)
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "IsMfSpecific" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, CSMD_FSP_TYPE_IO, "ResourceId" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, CSMD_FSP_VERS_IO, "ResourceVersion" );
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "FSP IO", "ResourceName" );
  }
  else if (ulResource == CSMD_RESOURCE_FSP_ENCODER)
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "IsMfSpecific" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, CSMD_FSP_TYPE_ENCODER, "ResourceId" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, CSMD_FSP_VERS_ENCODER, "ResourceVersion" );
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "FSP Encoder", "ResourceName" );
  }
  else if (ulResource == CSMD_RESOURCE_FSP_POWER_SUPPLY)
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "IsMfSpecific" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, CSMD_FSP_TYPE_POWERSUPPLY, "ResourceId" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, CSMD_FSP_VERS_POWERSUPPLY, "ResourceVersion" );
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "FSP PowerSupply", "ResourceName" );
  }
  else
  {
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "IsMfSpecific");
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ResourceId" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ResourceVersion" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ResourceName" );
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Resource" );
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Resources");

  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;

} /* end: CSMD_Serc_Mon_Resources() */


/********************************/
/* Sub-function for "Timing" */
/********************************/

CSMD_FUNC_RET CSMD_Serc_Mon_Timing( const CSMD_INSTANCE  *prCSMD_Instance,
                                    CSMD_CHAR           **pcText,
                                    const CSMD_CHAR      *pcEnd,
                                    CSMD_ULONG           *pulIndentation,
                                    CSMD_ULONG            ulSlaveIdx,
                                    CSMD_BOOL             boEvalTiming )
{

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Timing");

  if (boEvalTiming)
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "true", "IsSlaveForTimingEvaluation" );
  }
  else
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "IsSlaveForTimingEvaluation" );
  }

  /* S-0-1032 Communication control */
  {
    CSMD_ULONG  ulCommunicationControl = 0UL;
    if (prCSMD_Instance->rPriv.aulSCP_Config[ulSlaveIdx] & (CSMD_SCP_SYNC_V3 | CSMD_SCP_SYSTIME | CSMD_SCP_SWC))
    {
      /* Master has configured the extended function field */
      ulCommunicationControl |= CSMD_S_0_1032_EF_MDT0;

      if (CSMD_HAL_IsSoftMaster( &prCSMD_Instance->rCSMD_HAL ) == TRUE)
      {
        /* Master quality grade: MST jitter > 1 microsecond */
        ulCommunicationControl |= CSMD_S_0_1032_MQUAL_GRADE;
      }

      if (prCSMD_Instance->rPriv.rSWC_Struct.boNoForwardLastSlave)
      {
        if (   (prCSMD_Instance->rSlaveList.ausProjSlaveAddList[ulSlaveIdx+2] == prCSMD_Instance->usSercAddrLastSlaveP1)
            || (prCSMD_Instance->rSlaveList.ausProjSlaveAddList[ulSlaveIdx+2] == prCSMD_Instance->usSercAddrLastSlaveP2))
        {
          /* Slave is last in line and no forwarding of Sercos telegrams is requested. */
          ulCommunicationControl |= CSMD_S_0_1032_LB_NO_FORWARD;
        }
      }
    }
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                             (CSMD_LONG)ulCommunicationControl,
                                             "CommunicationControl" );
  }

  /* S-0-1002 Communication Cycle time (tScyc) */
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.ulCommCycleTime_S01002,
                                           "CommunicationCycleTime" );

  /* S-0-1003  Allowed MST losses in CP3/CP4 */
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].rTiming.usMaxNbrTelErr_S1003,
                                           "AllowedMstLosses" );

  if (prCSMD_Instance->rPriv.aulSCP_Config[ulSlaveIdx] & (CSMD_SCP_SYNC | CSMD_SCP_CYC))
  {
    /* S-0-1005 Maximum Producer processing Time (t5) */
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                             (CSMD_LONG)prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].rTiming.ulMinFdbkProcTime_S01005,
                                             "MaximumProducerProcessingTime" );

    /* S-0-1006 AT0 transmission starting time (t1) */
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                             (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.ulATTxStartTimeT1_S01006,
                                             "At0TransmissionStartingTime" );
  }

  if (prCSMD_Instance->rPriv.aulSCP_Config[ulSlaveIdx] & CSMD_SCP_SYNC)
  {
    /* S-0-1007 Synchronization time (tSync) */
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                             (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.ulSynchronizationTime_S01007,
                                             "SynchronizationTime" );
  }

  /* S-0-1017[0] Begin of the UC channel */
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rUC_Channel.ulBegin_T6_S01017,
                                           "UcTransmissionTimeStart" );

  /* S-0-1017[1] End of the UC channel */
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rUC_Channel.ulEnd_T7_S01017,
                                           "UcTransmissionTimeStop" );

  if (prCSMD_Instance->rPriv.aulSCP_Config[ulSlaveIdx] & (CSMD_SCP_SYNC_V2 | CSMD_SCP_CYC))
  {
    /* S-0-1047 Maximum Consumer Processing Time (t11) */
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                             (CSMD_LONG)prCSMD_Instance->rConfiguration.parSlaveConfig[ulSlaveIdx].rTiming.ulMaxConsActTimeT11_S01047,
                                             "MaximumConsumerProcessingTime" );
  }

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.usMDT_Length_S01010[0],
                                           "LengthOfMdt0" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.usMDT_Length_S01010[1],
                                           "LengthOfMdt1" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.usMDT_Length_S01010[2],
                                           "LengthOfMdt2" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.usMDT_Length_S01010[3],
                                           "LengthOfMdt3" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.usAT_Length_S01012[0],
                                           "LengthOfAt0" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.usAT_Length_S01012[1],
                                           "LengthOfAt1" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.usAT_Length_S01012[2],
                                           "LengthOfAt2" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)prCSMD_Instance->rConfiguration.rComTiming.usAT_Length_S01012[3],
                                           "LengthOfAt3" );

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Timing" );

  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;

} /* end: CSMD_Serc_Mon_Timing() */


/**********************************/
/* Sub-function for  "Connection" */
/**********************************/

CSMD_FUNC_RET CSMD_Serc_Mon_ConfigurationSlave( const CSMD_INSTANCE         *prCSMD_Instance,
                                                CSMD_CHAR                  **pcText,
                                                const CSMD_CHAR             *pcEnd,
                                                CSMD_ULONG                  *pulIndentation,
                                                const CSMD_ULONG             ulConnectionInstance,
                                                const CSMD_CONN_IDX_STRUCT   arConnIdxList,
                                                const CSMD_ULONG             ulTopologyI,
                                                const CSMD_ULONG             ulSercosA )
{
  CSMD_FUNC_RET e__return;
  CSMD_LONG     lLength;
  CSMD_ULONG    ulSlaveIdx;

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Connection" );

  *pcText = CSMD_Serc_XML_Element_Begin( *pcText, pcEnd, pulIndentation, "SercosSlaveIdentification" );
  lLength = sprintf( *pcText, "Slave %lu (Addr. %lu)", ulTopologyI, ulSercosA );
  *pcText = *pcText + lLength;
  *pcText = CSMD_Serc_XML_Element_End( *pcText, pcEnd, "SercosSlaveIdentification" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(ulConnectionInstance), "ConnectionInstance" );

  ulSlaveIdx = prCSMD_Instance->rSlaveList.ausProjSlaveIdxList[ulSercosA];
  if (prCSMD_Instance->rPriv.aulSCP_Config[ulSlaveIdx] & CSMD_SCP_VARCFG)
  {
    /* Element <ConnectionSetup> only for slaves with SCP_VarCFG */
    e__return = CSMD_Serc_Mon_ConnectionSetup( pcText,
                                               pcEnd,
                                               pulIndentation,
                                               prCSMD_Instance->rConfiguration.parConfiguration[arConnIdxList.usConfigIdx].usS_0_1050_SE1 );
    if (e__return != CSMD_NO_ERROR)
    {
      return e__return;
    }
  }
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                            (CSMD_LONG)(prCSMD_Instance->rConfiguration.parConnection[arConnIdxList.usConnIdx].usS_0_1050_SE2), "ConnectionNumber" );

  e__return = CSMD_Serc_Mon_TelegramOffset( pcText,
                                            pcEnd,
                                            pulIndentation,
                                            prCSMD_Instance->rConfiguration.parConnection[arConnIdxList.usConnIdx].usS_0_1050_SE3 );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, 0, "MaxLengthOfConnection" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                           (CSMD_LONG)(prCSMD_Instance->rConfiguration.parConnection[arConnIdxList.usConnIdx].usS_0_1050_SE5), "CurrentLengthOfConnection" );

  if (prCSMD_Instance->rPriv.aulSCP_Config[ulSlaveIdx] & CSMD_SCP_VARCFG)
  {
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                             (CSMD_LONG)(prCSMD_Instance->rConfiguration.parConnection[arConnIdxList.usConnIdx].ulS_0_1050_SE10), "ProducerCycleTimeInNs" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation,
                                             (CSMD_LONG)(prCSMD_Instance->rConfiguration.parConnection[arConnIdxList.usConnIdx].usS_0_1050_SE11), "AllowedDataLosses" );
  }
  else
  {
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ProducerCycleTimeInNs");
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, 1, "AllowedDataLosses" );
  }

  e__return = CSMD_Serc_Mon_ConnectionElements( pcText,
                                                pcEnd,
                                                pulIndentation,
                                                prCSMD_Instance->rConfiguration.parConfiguration[arConnIdxList.usConfigIdx].ulS_0_1050_SE6);
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Connection" );

  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/*****************************************/
/* Sub-function for  "Connection" unused */
/*****************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_ConfigSlave_Unused( CSMD_CHAR        **pcText,
                                                const CSMD_CHAR   *pcEnd,
                                                CSMD_ULONG        *pulIndentation,
                                                const CSMD_ULONG   ulConnectionInstance,
                                                const CSMD_ULONG   ulTopologyI,
                                                const CSMD_ULONG   ulSercosA )
{
  CSMD_FUNC_RET e__return;
  CSMD_LONG     lLength;

  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Connection" );

  *pcText = CSMD_Serc_XML_Element_Begin( *pcText, pcEnd, pulIndentation, "SercosSlaveIdentification" );
  lLength = sprintf( *pcText, "Slave %lu (Addr. %lu)", ulTopologyI, ulSercosA );
  *pcText = *pcText + lLength;
  *pcText = CSMD_Serc_XML_Element_End( *pcText, pcEnd, "SercosSlaveIdentification" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(ulConnectionInstance), "ConnectionInstance" );

  e__return = CSMD_Serc_Mon_ConnectionSetup( pcText,
                                             pcEnd,
                                             pulIndentation,
                                             0 );
  if (e__return != CSMD_NO_ERROR)
  {
    return e__return;
  }

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, 0, "ConnectionNumber" );

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, 0, "MaxLengthOfConnection" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, 0, "CurrentLengthOfConnection" );
  *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ProducerCycleTimeInNs" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, 1, "AllowedDataLosses" );
  *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ConnectionElements" );

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Connection" );

  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/***************************************/
/* Sub-function for  "ConnectionSetup" */
/***************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_ConnectionSetup( CSMD_CHAR         **pcText,
                                             const CSMD_CHAR    *pcEnd,
                                             CSMD_ULONG         *pulIndentation,
                                             const CSMD_USHORT   usConnectionSetup )
{
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "ConnectionSetup");

  if (usConnectionSetup & CONN_SETUP_USAGE)
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Used", "UsageOfConnection" );
  }
  else
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "NotUsed", "UsageOfConnection" );
  }

  if (usConnectionSetup & CONN_SETUP_FUNCTION)
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Producer", "FunctionWithinConnection" );
  }
  else
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Consumer", "FunctionWithinConnection" );
  }

  {
    CSMD_ULONG ulSource = usConnectionSetup & CONN_SETUP_SOURCE;
    if (ulSource == CONN_SETUP_SOURCE_MASTER)
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Master", "SourceOfConfiguration" );
    }
    else if (ulSource == CONN_SETUP_SOURCE_EXTERNAL)
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "External", "SourceOfConfiguration" );
    }
    else
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Reserved", "SourceOfConfiguration" );
    }
  }

  if (usConnectionSetup & CONN_SETUP_SOURCE_EXPECTATION)
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "WithoutExpectation", "MethodOfProcessing" );
  }
  else
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "WithExpectation", "MethodOfProcessing" );
  }

  {
    CSMD_ULONG ulType = usConnectionSetup & CONN_SETUP_SOURCE_TYPE;
    if (ulType == CONN_SETUP_SOURCE_TYPE_LIST)
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "VariableConfiguration", "TypeOfConfiguration" );
    }
    else if (ulType == CONN_SETUP_SOURCE_TYPE_CONTAIN)
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "WithConnectionLength", "TypeOfConfiguration" );
    }
    else if (ulType == CONN_SETUP_SOURCE_TYPE_FSP_DRV)
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "StandardTelegram", "TypeOfConfiguration" );
    }
    else
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Reserved", "TypeOfConfiguration" );
    }
  }

  {
    CSMD_ULONG ulTypeConn = usConnectionSetup & CONN_SETUP_SOURCE_TYPE_CONN;
    if (ulTypeConn == CONN_SETUP_SOURCE_TYPE_CONN_SYNC)
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "ClockSynchronous", "TypeOfConnection" );
    }
    else if (ulTypeConn == CONN_SETUP_SOURCE_TYPE_CONN_ASYNC_WD)
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "NonSynchronousWithWatchdog", "TypeOfConnection" );
    }
    else if (ulTypeConn == CONN_SETUP_SOURCE_TYPE_CONN_ASYNC)
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "NonSynchronousWithoutWatchdog", "TypeOfConnection" );
    }
    else /* (ulTypeConn == CONN_SETUP_SOURCE_TYPE_CONN_CYCLIC) */
    {
      *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "Cyclic", "TypeOfConnection" );
    }
  }

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "ConnectionSetup");
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/*************************************/
/* Sub-function for "TelegramOffset" */
/*************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_TelegramOffset( CSMD_CHAR         **pcText,
                                            const CSMD_CHAR    *pcEnd,
                                            CSMD_ULONG         *pulIndentation,
                                            const CSMD_USHORT   usTelegramOffset )
{
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "TelegramOffset");

  if ( usTelegramOffset & CSMD_S_0_1050_SE3_TELTYPE_MDT)
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "MDT", "MdtOrAt" );
  }
  else
  {
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "AT", "MdtOrAt" );
  }

  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(usTelegramOffset & 0xf000), "TelegramNumber" );
  *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, (CSMD_LONG)(usTelegramOffset & 0x07ff), "ByteOffset" );

  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "TelegramOffset");
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }
  return CSMD_NO_ERROR;
}


/*************************************/
/* Sub-function "ConnectionElements" */
/*************************************/

CSMD_FUNC_RET CSMD_Serc_Mon_ConnectionElements( CSMD_CHAR        **pcText,
                                                const CSMD_CHAR   *pcEnd,
                                                CSMD_ULONG        *pulIndentation,
                                                const CSMD_ULONG  *pulIDN )
{
  CSMD_ULONG    ul_ConN;
  CSMD_ULONG    ulNbrConn;
  CSMD_CHAR     acIdnString[18];
  CSMD_ULONG    ulStringLen = sizeof( acIdnString );
  CSMD_LONG     lByteOffset;
  CSMD_LONG     lByteLength;
  CSMD_FUNC_RET e__return;

  ulNbrConn = *((CSMD_USHORT *)(CSMD_VOID *)pulIDN) / 4U; /* Get number of elements of the IDN list */
  
  *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "ConnectionElements");

  for (ul_ConN = 0; ul_ConN < ulNbrConn; ul_ConN++)
  {
    lByteOffset = 0;
    lByteLength = 4;  /* set to 4 bytes to prevent SercosMonitor (V2.0.0) warnings */

    *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "ConnectionElement");

    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, lByteOffset, "ElementByteOffset" );
    *pcText = CSMD_Serc_XML_Element_Dezimal( *pcText, pcEnd, pulIndentation, lByteLength, "ElementByteLength" );

    e__return = CSMD_Serc_ConvIdnToString( pulIDN[ul_ConN+1], acIdnString, ulStringLen);
    if (e__return != CSMD_NO_ERROR)
    {
      return e__return;
    }
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, acIdnString, "ElementShortName" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ElementName" );

    *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "ElementIdn");

    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, acIdnString, "IdnString" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "NameAsByteList" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "Name" );

    *pcText = CSMD_Serc_XML_Node_Begin( *pcText, pcEnd, pulIndentation, "Attribute");
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "DataLength" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "DisplayFormat" );
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "IsProcedureCommand" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "PlacesAfterDecimalPoint" );
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "IsWriteProtectedInCp4" );
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "IsWriteProtectedInCp3" );
    *pcText = CSMD_Serc_XML_Element_String( *pcText, pcEnd, pulIndentation, "false", "IsWriteProtectedInCp2" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "WriteProtection" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "ConversionFactor" );
    *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "Attribute");

    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "UnitAsByteList" );

    *pcText = CSMD_Serc_XML_Element_Begin( *pcText, pcEnd, pulIndentation, "Unit" );
    *pcText = CSMD_Serc_XML_Element_End( *pcText, pcEnd, "Unit" );

    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "MinimumValueAsByteList" );

    *pcText = CSMD_Serc_XML_Element_Begin( *pcText, pcEnd, pulIndentation, "MinimumValue" );
    *pcText = CSMD_Serc_XML_Element_End( *pcText, pcEnd, "MinimumValue" );

    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "MaximumValueAsByteList" );

    *pcText = CSMD_Serc_XML_Element_Begin( *pcText, pcEnd, pulIndentation, "MaximumValue" );
    *pcText = CSMD_Serc_XML_Element_End( *pcText, pcEnd, "MaximumValue" );

    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "OperationDataAsByteList" );
    *pcText = CSMD_Serc_XML_Empty_Element( *pcText, pcEnd, pulIndentation, "OperationData" );

    *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "ElementIdn");

    *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "ConnectionElement");
    if (*pcText > pcEnd)
    {
      return CSMD_BUFFER_TOO_SMALL;
    }
  }
  *pcText = CSMD_Serc_XML_Node_End( *pcText, pcEnd, pulIndentation, "ConnectionElements");
  if (*pcText > pcEnd)
  {
    return CSMD_BUFFER_TOO_SMALL;
  }

  return CSMD_NO_ERROR;
}


/*****************************************/
/* Sub-function to convert IDN to String */
/*****************************************/

CSMD_FUNC_RET CSMD_Serc_ConvIdnToString( const CSMD_ULONG  ulIDN,
                                         CSMD_CHAR        *pcIdnString,
                                         const CSMD_ULONG  ulStringLen )
{

  CSMD_ULONG ul__SI  =  ulIDN >> 24;                /* 31-24: structure instance */
  CSMD_ULONG ul__SE  = (ulIDN & 0x00FF0000) >> 16;  /* 23-16: structure element  */
  CSMD_UCHAR  c__SP  = 'S';                         /* 15   : standard or product specific IDN */
  CSMD_ULONG ul__Set = (ulIDN & 0x00007000) >> 12;  /* 14-12: parameter set */
  CSMD_ULONG ul__NO  = (ulIDN & 0x00000FFF);        /* 11-0 : data block number / function group */

  /* "S-7-4095.255.255" => minimal length of the string: 18 bytes */
  if (ulStringLen < 17)
    return(CSMD_SYSTEM_ERROR);
  
  (CSMD_VOID) CSMD_HAL_memset( pcIdnString, 0, ulStringLen );

  if (ulIDN & 0x8000) c__SP = 'P';

  sprintf( pcIdnString,"%c-%.1lu-%.4lu.%lu.%lu",
           c__SP,
           ul__Set,
           ul__NO,
           ul__SI,
           ul__SE );

  return(CSMD_NO_ERROR);
}


/* Generate start of element segment with current indentation and line feed and increase indentation: "<StartTag>\n" */
CSMD_CHAR * CSMD_Serc_XML_Node_Begin( CSMD_CHAR       *pcString,
                                      const CSMD_CHAR *pcEnd,
                                      CSMD_ULONG      *pulIndentation,
                                      CSMD_CHAR        acStartTAG[] )
{
  if (pcString < pcEnd)
  {
    CSMD_LONG lLength;
    (CSMD_VOID) CSMD_HAL_memset( pcString, INDENT_CHAR, *pulIndentation );
    lLength = (CSMD_LONG)*pulIndentation + sprintf( &pcString[*pulIndentation],"%s%s%s", "<", acStartTAG, ">\n" );

    *pulIndentation = (*pulIndentation + INDENT_WIDTH) & MAX_INDENTATION_MASK;
    return &pcString[lLength];
  }
  else
  {
    return pcString;
  }
}


/* Decrease indentation and generate end of element segment with current indentation and line feed: "</EndTag>\n" */
CSMD_CHAR * CSMD_Serc_XML_Node_End( CSMD_CHAR       *pcString,
                                    const CSMD_CHAR *pcEnd,
                                    CSMD_ULONG      *pulIndentation,
                                    CSMD_CHAR        acEndTAG[] )
{
  if (pcString < pcEnd)
  {
    CSMD_LONG lLength;
    *pulIndentation = ((*pulIndentation - INDENT_WIDTH) & MAX_INDENTATION_MASK);

    (CSMD_VOID) CSMD_HAL_memset( pcString, INDENT_CHAR, *pulIndentation );
    lLength = (CSMD_LONG)*pulIndentation + sprintf( &pcString[*pulIndentation],"%s%s%s", "</", acEndTAG, ">\n" );
    return &pcString[lLength];
  }
  else
  {
    return pcString;
  }
}


/* Generate begin of element segment with current indentation: "<Elementname>" */
CSMD_CHAR * CSMD_Serc_XML_Element_Begin( CSMD_CHAR        *pcString,
                                         const CSMD_CHAR  *pcEnd,
                                         const CSMD_ULONG *pulIndentation,
                                         CSMD_CHAR         acElement[] )
{
  if (pcString < pcEnd)
  {
    CSMD_LONG lLength;
    (CSMD_VOID) CSMD_HAL_memset( pcString, INDENT_CHAR, *pulIndentation );
    lLength = (CSMD_LONG)*pulIndentation + sprintf( &pcString[*pulIndentation],"%s%s%s", "<", acElement, ">" );
    return &pcString[lLength];
  }
  else
  {
    return pcString;
  }
}


/* Generate end of element segment with line feed: "</Elementname>\n" */
CSMD_CHAR * CSMD_Serc_XML_Element_End( CSMD_CHAR       *pcString,
                                       const CSMD_CHAR *pcEnd,
                                       CSMD_CHAR        scElement[] )
{
  if (pcString < pcEnd)
  {
    CSMD_LONG lLength;
    lLength = sprintf( pcString,"%s%s%s", "</", scElement, ">\n" );
    return &pcString[lLength];
  }
  else
  {
    return pcString;
  }
}


/* Generate element with signed integer value: "<Elementname>Value</Elementname>" */
CSMD_CHAR * CSMD_Serc_XML_Element_Dezimal( CSMD_CHAR        *pcString,
                                           const CSMD_CHAR  *pcEnd,
                                           const CSMD_ULONG *pulIndentation,
                                           CSMD_LONG         lValue,
                                           CSMD_CHAR         acElement[] )
{
  if (pcString < pcEnd)
  {
    CSMD_LONG lLength;

    (CSMD_VOID) CSMD_HAL_memset( pcString, INDENT_CHAR, *pulIndentation );
    lLength = (CSMD_LONG)*pulIndentation + sprintf( &pcString[*pulIndentation],"%s%s%s%d", "<", acElement, ">", (CSMD_INT)lValue );

    lLength += (CSMD_LONG)sprintf( &pcString[lLength],"%s%s%s", "</", acElement, ">\n" );
    return &pcString[lLength];
  }
  else
  {
    return pcString;
  }
}


/* Generate element with char string: "<Elementname>String</Elementname>" */
CSMD_CHAR * CSMD_Serc_XML_Element_String( CSMD_CHAR        *pcString,
                                          const CSMD_CHAR  *pcEnd,
                                          const CSMD_ULONG *pulIndentation,
                                          const CSMD_CHAR   acValue[],
                                          CSMD_CHAR         acElement[] )
{
  if (pcString < pcEnd)
  {
    CSMD_LONG lLength;

    (CSMD_VOID) CSMD_HAL_memset( pcString, INDENT_CHAR, *pulIndentation );
    lLength = (CSMD_LONG)*pulIndentation + sprintf( &pcString[*pulIndentation],"%s%s%s%s", "<", acElement, ">", acValue );

    lLength += (CSMD_LONG)sprintf( &pcString[lLength],"%s%s%s", "</", acElement, ">\n" );
    return &pcString[lLength];
  }
  else
  {
    return pcString;
  }
}


/* Generate empty element: "<Elementname />" */
CSMD_CHAR * CSMD_Serc_XML_Empty_Element( CSMD_CHAR        *pcString,
                                         const CSMD_CHAR  *pcEnd,
                                         const CSMD_ULONG *pulIndentation,
                                         CSMD_CHAR         acElement[] )
{
  if (pcString < pcEnd)
  {
    CSMD_ULONG ulLength;

    (CSMD_VOID) CSMD_HAL_memset( pcString, INDENT_CHAR, *pulIndentation );
    ulLength = *pulIndentation + (CSMD_ULONG)sprintf( &pcString[*pulIndentation],"%s%s%s", "<", acElement, " />\n" );
    return &pcString[ulLength];
  }
  else
  {
    return pcString;
  }
}


/*! \endcond */ /* PRIVATE */

#endif  /* End: #ifdef CSMD_SERCOS_MON_CONFIG */



/*
--------------------------------------------------------------------------------
  Modification history
--------------------------------------------------------------------------------

07-Jan-2014 RL: CSMD Sercos Monitor Configuration
    -first Version 
27 Mar 2014 WK
  FEAT-00051252 - Generation of configuration files for the Sercos Monitor
  - Fixed lint messages. Remove unused function arguments.
  - Replaced strcmp(), memcpy() and memset() with HAL functions.
16 Apr 2014 Wk
  - Bit list are machine and compiler dependent! Removed bit list
    rS1050BitMask and adjust the function CSMD_Serc_Mon_ConnectionSetup()
23 Apr 2014 WK
  - Adjustments for configuration version 1.1
  - Removed elements
      "ConnectedToSubdevice", "FunctionRevision", "HardwareRevision",
      "SoftwareRevision", "FirmwareLoaderRevision", "OffsetsRelativeTo"
  - Removed element "OffsetRelativeTo".
    Telegram offsets always related to end of MST.
  - Output with indentation of elements.
  - Added element "NetworkConfigurationElement".
24 Apr 2014 WK
  - Set configuration version to 1.2
  - Fill element "ConfigurationName".
  - Added element "Resources".
  - Fixed element "ConnectedToMasterPort". Value topology dependent.
25 Apr 2014 WK
  - Slave configurations with right topology and port information.
    Fixed topological order.
29 Apr 2014 Wk
  - Shifted buffer overflow check to the output functions.
  - CSMD_Serc_Mon_Config()
    Added parameter for the number of characters output.
    Added check for minimum buffer length.
  - Removed element "MechanismOfProducing".
  - Try to evaluate the FSP-Type and fill Element "Resource".
  - Added output for unused connections.
12 May 2014 WK
  - CSMD_Serc_Mon_NetworkTopology()
    Adjust string for No-link and Defect-Ring.
10 Jul 2014 WK
  - Change value of element "ElementByteLength" from 0 to 4
    to prevent warnings of SercosMonitor 2.0.0
30 Jul 2014 WK
  - Set configuration version to 1.3 for SercosMonitor 2.1.1
  - Added element "UpdateOffsetsAndLengthsOfConnectionElements".
  - Removed element "NetworkTopology".
26 Aug 2014 WK
  - For SercosMonitor 2.1.2
    Added element <Timing> for each slave with the following attributes
    depending on SCP configuration:
      <IsSlaveForTimingEvaluation>
      <CommunicationCycleTime>
      <MaximumProducerProcessingTime>
      <At0TransmissionStartingTime>
      <SynchronizationTime>
      <UcTransmissionTimeStart>
      <UcTransmissionTimeStop>
      <MaximumConsumerProcessingTime>
      <LengthOfMdt0>
      <LengthOfMdt1>
      <LengthOfMdt2>
      <LengthOfMdt3>
      <LengthOfAt0>
      <LengthOfAt1>
      <LengthOfAt2>
      <LengthOfAt3>
27 Aug 2014 WK
  - Element <ConnectionSetup> only for slaves with SCP_VarCFG.
  - Default values for slaves with SCP_FixCFG for elements
    <ProducerCycleTimeInNs> and <AllowedDataLosses>.
26 Nov 2014 WK
  - Defdb00000000
    For SercosMonitor 2.2.0
    - Added attribute <CommunicationControl> to element <Timing>.
    - Change default value of element <AllowedDataLosses> from 0 to 1.
02 Feb 2015 WK
  - Defdb00000000
    For SercosMonitor 2.5.0
    Added element <Master configuration> with element <SvcBusyTimeout> and
    the following attributes: <Enabled>, <Value>
11 Feb 2015 WK
  - Defdb00176768
    CSMD_Serc_Mon_Timing(): Adjustments regarding soft master.
25 Feb 2015 WK
  - FEAT-00059338 - Conversion of redefined data types to CSMD types.
28 Apr 2015 WK
  - Defdb00178597
    CSMD_Serc_Mon_Config(), CSMD_Serc_Mon_ConnectionElements()
    Fixed type castings for 64-bit systems.
27 May 2015 WK
  - Defdb00179390
    Change from LGPL to a modified MIT License.
05 Nov 2015 WK
  - Defdb00182757
    Including the header CSMD_USER.h and CSMD_TYPE_HEADER removed.
16 Nov 2015 WK
  - Defdb00000000
    Test-Code for sprintf has been removed.
18 Jul 2016 WK
  Defdb00000000
  - Minor changes for SercosMonitor 3.0.0:
  - Added empty attribute <OperationData> to element <ElementIdn>
  - Added <Revision> node (major=2, minor=5) to <SercosMonitorSettings>
  - Added attribute <AllowedMstLosses> to element <Timing>.
  Defdb00182067
    Static function definitions removed.
  
--------------------------------------------------------------------------------
*/
